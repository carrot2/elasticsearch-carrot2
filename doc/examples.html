<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Carrot² search results clustering plugin for Elasticsearch (REST API)</title>

    <link href="assets/css/bootstrap.min.css" rel="stylesheet" />
    <link href="assets/css/prettify.css" rel="stylesheet" />

    <style>
      body {
        margin: 10px;
      }

      #reqdump {
        background-color: #e5e5e5;
      }

      #sampleIndex, #noes {
        display: none;
      }

      pre.example, pre.result {
        height: auto;
        max-height: 400px;
        overflow: auto;
      }

      pre + div.executable-buttons {
        margin-top: -10px;
        margin-bottom: 20px;
      }

      section.api-method {
      }

      .api-method {
        margin-top: 3em;
      }

      .api-method h5 {
      }

      @media print {
        .executable-buttons {
          display: none;
        }
      }
    </style>
  </head>

  <body>
    <div class="container">
      <div class="row" id="noes">
        <div class="span12">
          <div class="alert alert-error">
            <i class="icon-exclamation-sign"></i> <strong>Elasticearch instance cannot be reached.</strong>
            This manual requires a running instance of ES to render examples.
          </div>
        </div>
      </div>

      <div class="row" id="sampleIndex">
        <div class="span12">
          <div class="alert alert-block">
            Indexing sample docs...
            <div class="progress progress-striped active">
              <div class="bar" style="width: 0%;"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="row">
        <div class="span12">
          <div class="page-header">
            <h1>elasticsearch-carrot2</h1>
          </div>

          <ul>
            <li><a href="#preliminaries">Preliminaries</a></li>
            <li><a href="#java-api">Java API</a></li>
            <li><a href="#rest-api">HTTP REST API</a> <br/>
              <small><code>[<a href="#list-algorithms">list</a>]</code></small>,
              <small><code>[<a href="#search-and-cluster">cluster</a>]</code></small>
            </li>
            <li><a href="#field-mapping">Field mapping</a></li>
            <li><a href="#algorithms">Selecting the algorithm</a></li>
            <li><a href="#init-attributes">Overriding algorithm attributes</a></li>
            <li><a href="#runtime-attributes">Overriding algorithm attributes at runtime</a></li>
            <li><a href="#multilingual-clustering">Multilingual clustering</a></li>
            <li><a href="#plugin-configuration">Plugin configuration</a></li>
          </ul>
        </div>
      </div>

      <section id="preliminaries">
        <div class="page-header" id="prereq"><h3>Preliminary concepts</h3></div>
        <div class="row">
          <div class="span8">
            <p>The clustering plugin attempts to automatically group together similar &quot;documents&quot; and
              assign human-readable labels to these groups. The clusters can be thought-of as &quot;dynamic facets&quot;
              generated for each unique query and set of search result hits. Take a look at the
              <a target="_blank" href="https://search.carrot2.org">Carrot<sup>2</sup>
              demo page</a> to see how this can be used in practice.</p>

            <p>Each document passed for clustering is composed of several logical parts: the document's identifier,
              title, main content and language code (only the identifier field is mandatory,
              everything else is optional). Either the title, main content or both should be provided to make the clustering
              process reasonable, otherwise there will be no input for the algorithm to work on.</p>
          </div>
          <div class="span4">
            <div class="alert alert-danger">
              <strong>Important!</strong>
              <p>Read this section first, it contains important
              information about clustering which will help understand what's going on behind
              the scenes.</p>
            </div>
          </div>
        </div>
        <div class="row">
          <div class="span12">
            <p>Documents indexed in Elasticsearch do not have to follow any predefined schema, so sections
              of the input JSON document need to be mapped to the logical layout required by the clustering plugin. An example
              mapping can look as illustrated in the figure below:</p>

            <p class="text-center"><img src="assets/img/mapping.png" alt="Logical field mapping" width="500" /></p>

            <p>Two document fields are mapped to the title. This is not an error: any number of fields can
              be mapped to either the title or the content—values of those fields
              will be concatenated and used for clustering.</p>

            <p>Another way to provide the title and content fields is to use the
              <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-highlighting.html">highlighter</a>. 
              This can 
              be useful to decrease the amount of text passed to the clustering
              algorithm (improves performance) or to make the content of documents passed for clustering
              more focused on the query (because highlights typically provide the context of query terms).
            </p>
            
            <p>The REST API examples <a href="#rest-api">below</a> demonstrate the API for field
              mapping in details.</p>
          </div>
        </div>
      </section>

      <section id="java-api">
        <div class="page-header"><h3>Java API</h3></div>
        <div class="row">
          <div class="span12">
            <p>The Java API for clustering search results implements all the backend functionality behind
            all REST requests described in the following parts of this document. For actual code utilizing
            the API see the source code of the plugin at <a href="https://github.com/carrot2/elasticsearch-carrot2">github</a>,
            especially the unit and integration tests.</p>
          </div>
        </div>
      </section>

      <section id="rest-api">
        <div class="page-header"><h3>HTTP (REST) API</h3></div>
        <div class="row">
          <div class="span12">
            <p>The HTTP REST API contains several methods closely reflecting the Java-side API's functionality. Each of
            these methods is described in detail below.</p>
          </div>
        </div>

        <section id="list-algorithms" class="api-method" style="position: relative">
          <div class="row">
            <div class="span11">
              <div class="well">
                <h4>List clustering algorithms</h4>
                <ul>
                  <li><code>/_algorithms</code> (<code>GET</code> or <code>POST</code>)</li>
                </ul>
              </div>

              <p>This action lists all available clustering algorithms. The returned identifiers can be used
                as a parameter to the <a href="#clustering-request">clustering</a> request.</p>
            </div>
          </div>

          <div class="row">
            <div class="span12">
              <h5>Request</h5>
              <p>A request to list the available algorithms is a simple <code>GET</code> or <code>POST</code> request to
                <code>/_algorithms</code> URL.</p>
            </div>
          </div>

          <div class="row">
            <div class="span12">
              <h5>Response</h5>
              <p>The response is a JSON object with an <code>algorithms</code> property which is a non-empty
                array of algorithm identifiers. The following example shows the algorithms available
                on this plugin instance. The default algorithm is the first one on the list.</p>
            </div>
          </div>

          <div class="row">
            <div class="span6">
            <pre class="executable example">
$.get(window.ES_URL + "/_algorithms", function(response) {
    $("#list-of-algorithms").text(
              JSON.stringify(response, null, "  "));
});
            </pre>
            </div>
            <div class="span6">
              <pre class="result" id="list-of-algorithms"></pre>
            </div>
          </div>
        </section>

        <section id="search-and-cluster" class="api-method">
          <div class="row">
            <div class="span12">
              <div class="well">
                <h4>Search documents and cluster results</h4>
                <ul>
                  <li><code>/_search_with_clusters</code> (<code>POST</code>, <code>GET</code>)</li>
                  <li><code>/{index}/_search_with_clusters</code> (<code>POST</code>, <code>GET</code>)</li>
                  <li><code>/{index}/{type}/_search_with_clusters</code> (<code>POST</code>, <code>GET</code>)</li>
                </ul>
              </div>

              <p>This action performs a search query, fetches matching hits and clusters them on-the-fly.</p>

              <p>The <code>index</code> and <code>type</code> URI segments implicitly bind the search request part of the
                message to a given index and document type, exactly as in the
                <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html">search request API</a>.</p>

              <p>A clustering request is a HTTP REST request, where the full set of parameters is supported via
                HTTP POST request with a JSON body. A limited subset of clustering functionality is also exposed
                via the HTTP GET method (and URL parameters).</p>
            </div>
          </div>

          <div class="row">
            <div class="span12">
              <h5>Request (HTTP POST)</h5>

              <p>A HTTP POST request should contain a JSON object with the following properties.</p>

              <dl class="dl-horizontal">
                <dt><code>search_request</code></dt>
                <dd><p><span class="badge badge-info">required</span>
                  The search request to fetch documents to be clustered. This section follows <strong>exactly</strong>
                  what <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html">
                  the search DSL</a> specifies, including all optional bells and whistles such as sorting, 
                  filtering, query DSL, highlighter, etc.</p>
                </dd>

                <dt><code>query_hint</code></dt>
                <dd><p><span class="badge badge-info">required</span>
                  This attribute specifies query terms used to fetch the matching documents.
                  This hint helps the clustering algorithm avoid trivial clusters that would be created around 
                  those frequent query terms. Typically the value of this parameter is identical to what the user 
                  typed in the search box. If possible, it should be pruned
                  from any boolean or search-engine specific operators which could affect the clustering process. The query
                  hint is obligatory but may be an empty string.</p>
                </dd>

                <dt><code>field_mapping</code></dt>
                <dd><p><span class="badge badge-info">required</span>
                  Defines how to map actual fields of the documents matching the <code>search_request</code> to
                  logical fields of the documents to be clustered. The value should be an object where keys indicate logical
                  document fields and values are arrays with field source specifications (content of fields
                  defined by these specifications is concatenated). For example this is a valid field mapping specification:</p>

                <pre class="linenums prettyprint">{
  "title":    [_source.subject],
  "content":  [_source.abstract, highlight.main],
  "language": [_source.lang]
}</pre>

                  <p>Any of the following logical document field names are valid:</p>
                  <dl class="dl-horizontal">
                    <dt><code>title</code></dt>
                    <dd><p>The title of the document.</p></dd>
                    <dt><code>content</code></dt>
                    <dd><p>The main body (content) of the document.</p></dd>
                    <dt><code>language</code></dt>
                    <dd><p>Optional language name for the title and content of a document. The language must be
                      consistent with language components installed and available in Carrot<sup>2</sup>. The
                      list of supported languages is logged at startup. Note that unsupported languages will
                      default to the main language of the request (<code>language</code> request parameter).
                    </p></dd>
                  </dl>

                  <p>The field source specification defines where the value is taken from: the search hit's fields, stored document's content,
                    or from the highlighter's output. The syntax of field source specification is as follows:</p>

                  <dl class="dl-horizontal">
                    <dt><code>_source.{fieldname}</code></dt>
                    <dd>Defines a source document's field (top-level property of the json document). This will
                      reparse the source document and fetch the appropriate value from there. Please see
                      <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-source-filtering.html">ES documentation</a> for options to filter just specific fields from source.
                    </dd>

                    <dt><code>highlight.{fieldname}</code></dt>
                    <dd>Defines a search hit's highlighted field. The highlighter output must also be configured
                      properly in the search request (see <a href="#field-mapping">field mapping example</a>).</dd>

                    <dt><code>fields.{fieldname}</code></dt>
                    <dd>Defines a stored field. <span class="badge blue">!</span> This syntax is deprecated and requires stored fields. See 
                    <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-stored-fields.html">ES documentation</a> for details
                    and preferably use <code>_source</code> syntax.
                    </dd>                      
                  </dl>
                </dd>
                

                <dt><code>algorithm</code></dt>
                <dd><p><span class="badge">optional</span>
                  Defines which clustering algorithm should be used for clustering. Names of all built-in clustering
                  algorithms are logged at startup and are also returned
                  from the <a href="#list-algorithms">list algorithms</a> request. The default algorithm is used, if value is empty or 
                  not provided.</p>
                </dd>

                <dt><code>max_hits</code></dt>
                <dd><p><span class="badge">optional</span>
                  If set to a non-negative number, the clustering response will be limited to
                  contain only a maximum of the given search hits. The clustering will still run
                  on a full window of results returned by the original search request. This option 
                  may be useful to decrease the size of clustering response; in an extreme case of
                  <code>max_hits</code> equal o 0, only clusters are returned
                  and they can be used as facets (for refining the query, but without the immediate
                  link to the search hits).</p>
                  
                  <p>Note that clusters may still reference documents not present in the returned (trimmed) 
                  hits window.</p>
                </dd>

                <dt><code>create_ungrouped</code></dt>
                <dd><p><span class="badge">optional</span>
                  If set to <code>true</code>, the documents not assigned to any cluster will form a synthetic
                  group appended at the end of all clusters. This is effectively the "other topics" group
                  created by Carrot<sup>2</sup> versions prior to 4.0.
                </dd>

                <dt><code>language</code></dt>
                <dd><p><span class="badge">optional</span>
                  Declares the default language for documents where field mapping for the logical
                  <code>language</code> field is not declared (or empty). The default value of this field
                  is <code>English</code>.
                </dd>

                <dt><code>attributes</code></dt>
                <dd><p><span class="badge">optional</span>
                  A JSON object with attributes overriding the default algorithm settings (per-query or runtime attributes
                  in Carrot<sup>2</sup> parlance).</p>
                </dd>
              </dl>

              <div class="alert alert-danger">
                <p><strong>Very important</strong></p>
                <p>Clustering requires at least a few dozen documents (hits) in order to make
                  sense. The clustering plugin clusters search results <strong>only</strong> (it does not look in the index, it does not
                  fetch additional documents). Make sure to specify the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-from-size.html"><code>size</code></a> of the
                  fetch window to be at least 100 documents. If your application does not need so many hits 
                  (document references), the response size can be trimmed by using <code>max_hits</code> parameter on
                  the clustering request.  
              </div>
            </div>
          </div>

          <div class="row">
            <div class="span12">
              <h5>Request (HTTP GET)</h5>

              <p>A HTTP GET clustering request supports a superset of HTTP URI parameters defined by Elasticsearch's
                <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-uri-request.html">URI search request</a>.
                All additional parameters correspond to those typically defined in the body of a clustering
                request sent via HTTP POST. Namely, the following parameters are supported by HTTP GET:</p>

              <dl class="dl-horizontal">
                <dt><code>field_mapping_*</code></dt>
                <dd><p><span class="badge badge-info">required</span>
                  This is a wildcard (a family) of parameters, each of which defines a logical field mapping, similar
                  to <code>field_mapping</code> map described in the HTTP POST request. A <code>field_mapping_title</code>
                  will specify the logical title's mapping, wheareas <code>field_mapping_content</code> will specify
                  the logical document content mapping.</p>

                  <p>The value of the mapping parameter is a comma-separated list of mapping specifications, as described
                  in the description of the POST request.</p>
                </dd>

                <dt><code>algorithm</code></dt>
                <dd><p><span class="badge">optional</span>
                  Identical semantics to <code>algorithm</code> attribute described in HTTP POST request.</p>
                </dd>

                <dt><code>query_hint</code></dt>
                <dd><p><span class="badge">optional</span>
                  Identical semantics to <code>query_hint</code> attribute described in HTTP POST request.
                  For GET requests the query hint is optional; if not present, the <code>q</code> attribute is used
                  as the default.</p>
                </dd>

                <dt><code>create_ungrouped</code></dt>
                <dd><p><span class="badge">optional</span>
                  If set to <code>true</code>, the documents not assigned to any cluster will form a synthetic
                  group appended at the end of all clusters. This is effectively the "other topics" group
                  created by Carrot<sup>2</sup> versions prior to 4.0.
                </dd>

                <dt><code>language</code></dt>
                <dd><p><span class="badge">optional</span>
                  Declares the default language for documents where field mapping for the logical
                  <code>language</code> field is not declared (or empty). The default value of this field
                  is <code>English</code>.
                </dd>
              </dl>

              <div class="alert alert-info">
                <p><strong>Important</strong></p>
                <p>A HTTP GET request offers a subset of the functionality of a full HTTP POST JSON syntax. For example,
                it is not possible to specify a field mapping to highlighted field values, define custom algorithm
                  attributes, etc. HTTP POST is recommended for production.</p>
              </div>

              <p>An example HTTP GET clustering request is shown below, with the resulting clusters shown
                on the right-hand side panel.</p>
            </div>
          </div>

          <div class="row">
            <div class="span6">
            <pre class="executable example" data-runbefore="defineDumpClusters">
var getUrl = window.ES_URL + "/test/test/_search_with_clusters?"
  + "q=data+mining&"
  + "size=100&"
  + "field_mapping_title=_source.title&"
  + "field_mapping_content=_source.content";

// Run HTTP GET via jquery and render cluster labels.
$.get(getUrl,
  function(response) {
    $("#cluster-httpget-result").text(
      dumpClusters([], response.clusters).join("\n"));
});
            </pre>
            </div>
            <div class="span6">
              <pre class="result" id="cluster-httpget-result"></pre>
            </div>
          </div>

          <div class="row">
            <div class="span12">
              <h5>Response</h5>

              <p>The response format is identical to a
                <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html">plain search request response</a>,
                with extra properties presented in the schematic output below.</p>

              <pre class="linenums prettyprint">{
  /* Typical search response fields. */
  "hits": { /* ... */ },

  /* Clustering response fields. */
  "clusters": [
    /* Each cluster is defined by the following. */
    {
      "id":    /* identifier */,
      "score": /* numeric score */,
      "label": /* primary cluster label */,
      "other_topics": /* if present, and true, this cluster groups
                         unrelated documents (no related topics) */,
      "phrases": [
        /* cluster label array, will include primary. */
      ],
      "documents": [
        /* This cluster's document ID references.
           May be undefined if this cluster holds sub-clusters only. */
      ],
      "clusters": [
        /* This cluster's subclusters (recursive objects of the same
           structure). May be undefined if this cluster holds documents only. */
      ],
    },
    /* ...more clusters */
  ],
  "info": {
    /* Additional information about the clustering: execution times,
       the algorithm used, etc. */
  }
}</pre>
              <p>Given the following function that recursively dumps clusters:</p>
              <pre class="linenums prettyprint" id="defineDumpClusters">
window.dumpClusters = function(arr, clusters, indent) {
  indent = indent ? indent : "";
  clusters.forEach(function(cluster) {
    arr.push(
        indent + cluster.label
        + (cluster.documents ? " [" + cluster.documents.length + " documents]"   : "")
        + (cluster.clusters  ? " [" + cluster.clusters.length  + " subclusters]" : ""));
    if (cluster.clusters) {
      dumpClusters(arr, cluster.clusters, indent + "  ");
    }
  });
  return arr;
}</pre>
              <p>We can dump all cluster labels of a clustering request with the following snippet of javascript:</p>
            </div>
          </div>

          <div class="row">
            <div class="span6">
            <pre class="executable example" data-runbefore="defineDumpClusters">
var request = {
  "search_request": {
    "query": {"match" : { "content": "data mining" }},
    "size": 100
  },

  "max_hits": 0,
  "query_hint": "data mining",
  "field_mapping": {
    "title": ["_source.title"],
    "content": ["_source.content"]
  }
};

$.post(window.ES_URL + "/test/test/_search_with_clusters",
  JSON.stringify(request),
  function(response) {
    $("#cluster-list-result").text(
      dumpClusters([], response.clusters).join("\n"));
});
            </pre>
            </div>
            <div class="span6">
              <pre class="result" id="cluster-list-result"></pre>
            </div>
          </div>


          <div class="row">
            <div class="span12">
              <p>The output will vary depending on the choice of clustering algorithm
                (and particular documents that made it to the hit list if search is not
                deterministic). The following example shows the same result as above
                but uses the <code>STC</code> algorithm. We don't need every search hit here
                so we will omit them in the response.</p>
            </div>

            <div class="span6">
            <pre class="executable example" data-runbefore="defineDumpClusters">
var request = {
  "search_request": {
    "query": {"match" : { "content": "data mining" }},
    "size": 100
  },

  "max_hits": 0,
  "query_hint": "data mining",
  "field_mapping": {
    "title": ["_source.title"],
    "content": ["_source.content"]
  },
  "algorithm": "STC"
};

$.post(window.ES_URL + "/test/test/_search_with_clusters",
  JSON.stringify(request), function(response) {
    $("#cluster-list-result2").text(
      dumpClusters([], response.clusters).join("\n"));
});
            </pre>
            </div>
            <div class="span6">
              <pre class="result" id="cluster-list-result2"></pre>
            </div>
          </div>

          <div class="row">
            <div class="span12">
              <p>A full response for a clustering request can look as shown below (note the difference in
                field mapping in this example).</p>
            </div>
          </div>

          <div class="row">
            <div class="span6">
            <pre class="executable example">
var request = {
  "search_request": {
    "_source": [ "title", "content" ],
    "query": {"match" : { "content": "data mining" }},
    "size": 100
  },

  "max_hits": 0,
  "query_hint": "data mining",
  "field_mapping": {
    "title": ["_source.title"],
    "content": ["_source.content"]
  }
};

$.post(window.ES_URL + "/test/test/_search_with_clusters",
  JSON.stringify(request),
  function(response) {
    $("#simple-request-result").text(
      JSON.stringify(response, false, "  "));
});
            </pre>
            </div>
            <div class="span6">
              <pre class="result" id="simple-request-result"></pre>
            </div>
          </div>
        </section>
      </section>


      <section id="field-mapping">
        <div class="page-header"><h3>A bit more about field mapping</h3></div>
        <div class="row">
          <div class="span12">
            <p>The field mapping section provides a connection between actual data and logical data
            to cluster on. The different field mapping sources
            (<code>_source.*</code>,
             <code>highlight.*</code> and
             <code>fields.*</code>) can be used to tune the amount of data returned in the request and
            the amount of text passed to the clustering engine (and in result the required processing cost).</p>

            <ul>
              <li><p>The <code>_source.*</code> mapping takes data directly from the source document, if <code>_source</code>
                is available as part of the search hit. The content pointed to by this mapping is not returned as
                part of the request, it is only used internally for clustering.</p>
                
                <p><span class="badge badge-warning">Important!</span>
                  Partial <code>_source</code> can be configured using
                  <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-source-filtering.html">
                  search request filtering</a> attributes.</p>
              </li>

              <li><p>The <code>fields.*</code> mapping requires stored fields in the schema. It is superseded by 
              <code>_source.*</code> filtering since ES 5.x release.</p></li>

              <li><p>The <code>highlight.*</code> mapping also must be accompanied by appropriate
                <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-highlighting.html"><code>highlight</code></a>
                declaration in the search request. The highlighting request specification can be used to tune the
                amount of content passed to the clustering engine (the number of fragments, their width, boundary, etc.). This
                is of particular importance when the documents are long (full content is stored): it is typical that
                clustering algorithms run perceptually &quot;better&quot; when focused on the context surrounding
                the query, rather than when presented with full content of all documents.
                Any highlighted content will also be returned as part of the request.</p></li>
            </ul>

            <p>Compare the clustering output for the following two requests. One is clustering on full
            content of the <code>content</code> fields, the other just on highlighted snippets
            around the <code>mining</code> term from the query (highlights come from the 
            same <code>content</code> field).</p>
          </div>
        </div>
        <div class="row">
          <div class="span6">
            <pre class="executable example">
var request = {
  "search_request": {
    "_source": ["url", "title", "content"],
    "query": {
      "query_string" : { 
        "default_field": "content",
        "query": "mining"
      }
    }, 
    "size": 100
  },

  "query_hint": "mining",
  "field_mapping": {
    "title":   ["_source.title"],
    "content": ["_source.content"]
  }
};

$.post(window.ES_URL + "/test/test/_search_with_clusters", JSON.stringify(request), function(response) {
  $("#fields-request").text(JSON.stringify(response, false, "  "));
  $("#fields-request-clusters").text(dumpClusters([], response.clusters).join("\n"));
});
            </pre>
          </div>

          <div class="span6">
            <pre class="executable example">
var request = {
  "search_request": {
    "_source": ["url", "title"],
    "query": {
      "query_string" : { 
        "default_field": "content",
        "query": "mining"
      }
    }, 
    "size": 100,
    "highlight" : {
      "pre_tags" :  ["", ""],
      "post_tags" : ["", ""],
      "fields" : {
        "content" : { "fragment_size" : 50, "number_of_fragments" : 2 }
      }
    },
  },

  "query_hint": "mining",
  "field_mapping": {
    "title":   ["_source.title"],
    "content": ["highlight.content"]
  }
};

$.post(window.ES_URL + "/test/test/_search_with_clusters", JSON.stringify(request), function(response) {
  $("#highlight-request").text(JSON.stringify(response, false, "  "));
  $("#highlight-request-clusters").text(dumpClusters([], response.clusters).join("\n"));
});
            </pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <p class="text-center"><i class="icon-arrow-down"></i></p>
            <pre class="result" id="fields-request"></pre>
          </div>
          <div class="span6">
            <p class="text-center"><i class="icon-arrow-down"></i></p>
            <pre class="result" id="highlight-request"></pre>
          </div>
        </div>
        
        <div class="row">
          <div class="span6">
            <p class="text-center"><i class="icon-arrow-down"></i></p>
            <pre class="result" id="fields-request-clusters"></pre>
          </div>
          <div class="span6">
            <p class="text-center"><i class="icon-arrow-down"></i></p>
            <pre class="result" id="highlight-request-clusters"></pre>
          </div>
        </div>        
      </section>


      <section id="algorithms">
        <div class="page-header"><h3>Selecting the algorithm</h3></div>
        <div class="row">
          <div class="span12">
            <p>The clustering plugin comes with several open-source algorithms from
              the <a href="https://project.carrot2.org">Carrot<sup>2</sup></a> project. An
              <a href="https://github.com/carrotsearch/elasticsearch-lingo3g">extension plugin</a> must be installed
              separately to add support for
              the commercial <a href="https://carrotsearch.com/lingo3g">Lingo3G</a> clustering
              algorithm.</p>

            <p>The question of which algorithm to choose depends on the amount of traffic (STC is faster than Lingo, 
              but arguably produces less intuitive clusters, Lingo3G is the fastest algorithm but is not free or 
              open source), expected result (Lingo3G provides hierarchical clusters, Lingo and STC provide flat 
              clusters), and the input data (each algorithm will cluster the input slightly differently). 
              There is no single answer as to which algorithm is "the best".</p>

            <p>Compare the clusters dumped for the following identical search request.</p>
          </div>
        </div>
        <div class="row">
          <div class="span6">
            <pre class="executable example" data-runbefore="defineDumpClusters">
var request = {
  "search_request": {
    "query": {"match" : { "content": "data mining" }},
    "size": 100
  },

  "query_hint": "data mining",
  "field_mapping": {
    "title":   ["_source.title"],
    "content": ["_source.content"]
  },
  "algorithm": "Lingo"
};

$.post(window.ES_URL + "/test/test/_search_with_clusters", JSON.stringify(request), function(response) {
  $("#request-algorithm1").text(dumpClusters([], response.clusters).join("\n"));
});
            </pre>
          </div>

          <div class="span6">
            <pre class="executable example">
var request = {
  "search_request": {
    "query": {"match" : { "content": "data mining" }},
    "size": 100
  },

  "query_hint": "data mining",
  "field_mapping": {
    "title":   ["_source.title"],
    "content": ["_source.content"]
  },
  "algorithm": "STC"
};

$.post(window.ES_URL + "/test/test/_search_with_clusters", JSON.stringify(request), function(response) {
  $("#request-algorithm2").text(dumpClusters([], response.clusters).join("\n"));
});
            </pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <p class="text-center"><i class="icon-arrow-down"></i></p>
            <pre class="result" id="request-algorithm1"></pre>
          </div>
          <div class="span6">
            <p class="text-center"><i class="icon-arrow-down"></i></p>
            <pre class="result" id="request-algorithm2"></pre>
          </div>
        </div>
      </section>


      <section id="init-attributes">
        <div class="page-header"><h3>Overriding algorithm attributes</h3></div>
        <div class="row">
          <div class="span12">
            <p>By default algorithms run with their default settings. There is currently
            no way of preconfiguring algorithm defaults. Use per-request overrides.</p>
          </div>
        </div>
      </section>


      <section id="runtime-attributes">
        <div class="page-header"><h3>Overriding algorithm attributes at runtime</h3></div>
        <div class="row">
          <div class="span12">
            <p>Clustering algorithms come with many attributes that modify their
              runtime behavior. If desired, certain attributes can be modified per-request. The following
              example shows how to modify the number of desired clusters randomly (execute
              the example a few times to see the difference).</p>
          </div>
        </div>
        <div class="row">
          <div class="span7">
            <pre class="executable example" data-runbefore="defineDumpClusters">
var request = {
  "search_request": {
    "query": {"match" : { "content": "data mining" }},
    "size": 100
  },

  "query_hint": "data mining",
  "field_mapping": {
    "title":   ["_source.title"],
    "content": ["_source.content"]
  },
  "algorithm": "Lingo",
  "attributes": {
     "desiredClusterCount": Math.round(5 + Math.random() * 5)
  }
};

$.post(window.ES_URL + "/test/test/_search_with_clusters", JSON.stringify(request), function(response) {
  $("#request-attributes").text(dumpClusters([], response.clusters).join("\n"));
});
            </pre>
          </div>
          <div class="span5">
            <pre class="result" id="request-attributes"></pre>
          </div>
        </div>
        <div class="row">
          <div class="span12">
            <p>Each clustering algorithm will have a different set of parameters. Refere to
              Carrot<sup>2</sup> releases as they come with
              <a href="https://github.com/carrot2/carrot2/releases">extensive documentation of those
                parameters</a>.</p>
          </div>
        </div>
      </section>


      <section id="multilingual-clustering">
        <div class="page-header"><h3>Multilingual clustering</h3></div>
        <div class="row">
          <div class="span12">
            <p>The field mapping specification can include a <code>language</code> element, which
            defines the name of the Carrot<sup>2</sup> language component
            to use for clustering. This information can be stored in the index based on apriori knowledge of
            the documents' source or a language detection filter applied at indexing time.</p>

            <p>The language hint makes it easier for clustering algorithms to separate documents
            from different languages on input and to pick the right language resources for clustering.
            If you do have multi-lingual query results (or query results in a language different
            than English), it is strongly advised to map the <code>language</code> field
              appropriately.</p>

            <p>Names of all supported languages are printed at clustering plugin's startup.</p>

            <p>Documents with language codes not available in Carrot<sup>2</sup> will default to the
              <code>language</code> parameter of the entire request.</p>

            <p>The following example demonstrates clustering of documents in multiple languages.
            Some documents are in German, some are in English. Note the default language is set
            to "Italian" (but each document declares its own corresponding language so it does
              not matter).</p>
          </div>
        </div>
        <div class="row">
          <div class="span7">
            <pre class="executable example" data-runbefore="defineDumpClusters">
var request = {
  "search_request": {
    "query": {"match_all" : {}},
    "size": 100
  },

  "query_hint": "bundestag",
  "algorithm": "Lingo",
  "language": "Italian",
  "field_mapping": {
    "title":    ["_source.title"],
    "content":  ["_source.content"],
    "language": ["_source.lang"]
  },
  "attributes": {
  }
};

$.post(window.ES_URL + "/test/test/_search_with_clusters", JSON.stringify(request), function(response) {
  $("#language-fieldmapping").text(dumpClusters([], response.clusters).join("\n"));
});
            </pre>
          </div>
          <div class="span5">
            <pre class="result" id="language-fieldmapping"></pre>
          </div>
        </div>
      </section>


      <section id="plugin-configuration">
        <div class="page-header"><h3>Plugin configuration</h3></div>
        <div class="row">
          <div class="span12">
            <p>The plugin comes with sensible defaults out of the box and should
            require no additional configuration. Customize only if really necessary.</p>

            <p>The following configuration properties can be tweaked at the global 
            ES configuration level.</p>

            <dl>
              <dt><code>{es.home}/config/elasticsearch.yml</code>,<br/>
                  <code>{es.home}/config/elasticsearch.json</code>,<br/>
                  <code>{es.home}/config/elasticsearch.properties</code></dt>
              <dd>
                <p>The main ES configuration file can be used to enable/ disable the plugin
                  and to tweak the resources assigned to clustering requests.</p>

                <dl class="dl-horizontal">
                  <dt><code>carrot2.enabled</code></dt>
                  <dd>If set to <code>false</code> disables the plugin, even if it is installed.</dd>
                </dl>
                <dl class="dl-horizontal">
                  <dt><code>threadpool.search.*</code></dt>
                  <dd>Clustering requests are executed on the search threadpool inside ES. It may be
                    necessary to tune the settings of this threadpool to limit the number of concurrent
                    clustering requests to the number of computational cores on the node (clustering
                    is CPU-intense). See <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-threadpool.html">
                    the relevant threadpool</a> documentation section in ES.
                  </dd>
                </dl>
              </dd>
            </dl>
            <p>The following configuration files and properties can be found inside the 
            plugin's ZIP file (<code>elasticsearch/config/</code> folder) or 
            under <code>{es.home}/config/elasticsearch-carrot2/</code> after 
            plugin installation).</p>

            <dl>
              <dt><code>carrot2.yml</code>,<br/>
                  <code>carrot2.json</code>,<br/>
                  <code>carrot2.properties</code></dt>
              <dd>
                <p>The master configuration file for the plugin.</p>

                <dl class="dl-horizontal">
                  <dt><code>resources</code></dt>
                  <dd><p>Resource lookup path for loading language component and other resources.</p>

                    <p>Note that if this option is defined, all required resources must be present under this
                      location. No other location will be scanned (no defaults from classpath).</p>
                  </dd>
                </dl>
              </dd>
            </dl>
            
            <p>If <a href="https://carrotsearch.com/lingo3g">Lingo3G</a>
              <a href="https://github.com/carrotsearch/elasticsearch-lingo3g">extension plugin</a> is installed and
              the algorithm is available, the license needs to be installed at any of the following locations.</p>

            <dl>
              <dt><code>{es.home}/config/license*.xml</code>,<br/>
                  <code>{plugin.zip}/elasticsearch/config/license*.xml</code></dt>
              <dd></dd>
            </dl>            
          </div>
        </div>
      </section>
    </div>

    <p style="margin-bottom: 3em;" />

    <script src="assets/js/jquery-2.0.2.min.js"></script>
    <script src="assets/js/sample-data.js"></script>
    <script src="assets/js/prettify.js"></script>
    <script src="assets/js/config.js"></script>
    <script>
      $(document).ready(function () {
        // Render the response of all the examples against a live instance.
        function renderExamples() {
          $("pre.executable").after(function() {
            var code = $(this).text();

            // Collect hooks before they're pretty printed.
            var runbefore = $(this).attr("data-runbefore");
            var runafter  = $(this).attr("data-runafter");
            if (runbefore) runbefore = $("#" + runbefore).text();
            if (runafter)  runafter = $("#" + runafter).text();

            var $button = $('<button class="btn btn-mini btn-info runs-example" type="button">Execute</button>').on("click", function() {
              if ($button.hasClass("disabled")) return;
              var self = {};
              (function() {
                runbefore && eval(runbefore);
                eval(code);
                runafter && eval(runafter);
              }).call(self);
            });

            var $buttonline = $('<div class="executable-buttons"></div>').append($button);
            return $buttonline;
          });

          // Configure pretty printed listings.
          $("pre.example").each(function(i,e) {
            e = $(e);
            $(e).text($(e).text().trim());
            e.addClass("linenums prettyprint")
          });
          prettyPrint();

          // Run all examples.
          $(".runs-example").click();
        }

        // Check if we have the document index. If not, index first.
        $.ajaxSetup({
          contentType: "application/json; charset=UTF-8"
        });
        
        $.ajax({
          url: window.ES_URL + "/_stats?pretty=true",
          success: function(response) {
            var indexReady = response &&
                             response.indices &&
                             response.indices.test;

            // Reindex once per window session, even if the index seems to be ready.
            if (indexReady) {
              if (sessionStorage) {
                var cookieName = "__documents_indexed";
                if (!sessionStorage[cookieName]) {
                  indexReady = false;
                }
                sessionStorage[cookieName] = true;
              } else {
                indexReady = false;
              }
            }

            if (!indexReady) {
              $("#sampleIndex").show();
              doIndex(function(current, total) {
                if (current < total) {
                  $("#sampleIndex .bar").css("width", Math.round(100 * current / total) + "%");
                } else {
                  $("#sampleIndex").slideUp(1000, renderExamples);
                }
              });
            } else {
              renderExamples();
            }
          },
          error: function() {
            $("#noes").slideDown(1000);
          }
        });
      });
    </script>
  </body>
</html>
